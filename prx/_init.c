// DO NOT EDIT THIS FILE UNLESS YOU KNOW WHAT YOU ARE DOING
// Look at mod.c for mod code

// PS3 system includes
#include <sys/prx.h>
#include <sys/tty.h>
#include <sys/syscall.h>

#include "lib/common.h"
#include "lib/shk.h"
#include "lib/config.h"

#include "modulelist.h"

// PRX initialization boilerplate
s32 _start( void );
SYS_MODULE_INFO( modPrx, 0, 1, 1 );
SYS_MODULE_START( _start );
SYS_MODULE_STOP( _stop );

// runtime initialisation
extern void* _shk_elf_prx_ptr_table;
extern void* _shk_prx_ptr_table;
extern void _runtimeSubstitute1Impl();
SHK_HOOK( void, _runtimeSubstitute1 );

void initRuntime()
{
    printf( "modprx: initialising runtime\n" );

    // initialize pointer to prx function pointer table in elf
    *(void**)&_shk_elf_prx_ptr_table = &_shk_prx_ptr_table;

    // bind hook to function that was substituted (copied to the prx) to make room for the loader
    SHK_BIND_HOOK( _runtimeSubstitute1, _runtimeSubstitute1Impl );
    
    printf( "modprx: runtime initialised\n" );
}

// Loads & initialises a module
ModuleInitStatus initModule( ModuleInfo* module )
{
    //printf( "modprx: initModule() '%s' (%s)\n", module->longName, module->shortName );

    if ( module->flags & MODULE_FLAG_INIT )
    {
        // module has already been loaded before
        if ( module->flags & MODULE_FLAG_ENABLED )
            return MODULE_INIT_STATUS_ENABLED;
        else
            return MODULE_INIT_STATUS_DISABLED;
    }

    // set init flag early to prevent infinite recursion
    module->flags |= MODULE_FLAG_INIT;

    // check if enabled
    ConfigSetting* toggleSetting = configGetSettingByName( module->toggleSettingName );
    if ( toggleSetting == NULL || toggleSetting->valueType != CONFIG_VALUE_TYPE_BOOL || !toggleSetting->value.boolValue )
    {
        printf( "modprx: module '%s' (%s) is not loaded because it has been disabled through the config\n", module->longName, module->shortName );
        return MODULE_INIT_STATUS_DISABLED;
    }

    // mark as enabled for now to satisfy recursive loads
    // if an error occurs while resolving dependencies, the flag is unset
    module->flags |= MODULE_FLAG_ENABLED;

    // init dependencies first
    printf( "modprx: module '%s' (%s) loading dependencies\n", module->longName, module->shortName );
    const char** dependency = module->dependencies;
    while ( *dependency != NULL )
    {
        printf( "modprx: module '%s' (%s) loading dependency %s\n", module->longName, module->shortName, *dependency );

        ModuleInfo* dependencyModule = moduleGetModuleByName( *dependency );
        if ( !dependencyModule )
        {
            printf( "modprx: module '%s' (%s) is not loaded because dependency module '%s' is not found\n", 
                module->longName, module->shortName, *dependency );
            return MODULE_INIT_STATUS_DEPENDENCY_INVALID;
        }

        ModuleInitStatus status = initModule( dependencyModule );

        // handle status
        switch ( status )
        {
            case MODULE_INIT_STATUS_DEPENDENCY_DISABLED:
                printf( "modprx: module '%s' (%s) not loaded because dependency module %s (%s) failed to load a dependency\n",
                     module->longName, module->shortName, dependencyModule->longName, dependencyModule->shortName );

                module->flags &= ~MODULE_FLAG_ENABLED;
                return MODULE_INIT_STATUS_DEPENDENCY_DISABLED;

            case MODULE_INIT_STATUS_DEPENDENCY_INVALID:
                printf( "modprx: module '%s' (%s) not loaded because dependency module %s (%s) failed to load a dependency\n",
                     module->longName, module->shortName, dependencyModule->longName, dependencyModule->shortName );

                module->flags &= ~MODULE_FLAG_ENABLED;
                return MODULE_INIT_STATUS_DEPENDENCY_INVALID;

            case MODULE_INIT_STATUS_DISABLED:
                printf( "modprx: module '%s' (%s) not loaded because dependency module %s (%s) is disabled\n",
                     module->longName, module->shortName, dependencyModule->longName, dependencyModule->shortName );

                module->flags &= ~MODULE_FLAG_ENABLED;
                return MODULE_INIT_STATUS_DEPENDENCY_DISABLED;

            case MODULE_INIT_STATUS_ENABLED:
                // good
                break;
        }

        dependency++;
    }

    // call module init
    printf( "modprx: initialising module '%s' (%s)\n", module->longName, module->shortName );
    if ( module->init ) module->init();
}

s32 _start( void )
{
    printf( "modprx: initialising\n" );
    initRuntime();

    // load config
    printf( "modprx: loading config\n" );
    configLoad( "config.yml" );

    printf( "modprx: initialising modules\n" );
    for ( u32 i = 0; i < moduleGetModuleCount(); ++i )
        initModule( moduleGetModuleByIndex( i ) );
    
    return SYS_PRX_START_OK;
}

s32 _stop( void )
{
    printf( "modprx: shutting down\n" );

    printf( "modprx: shutting down modules\n" );
    for ( u32 i = 0; i < moduleGetModuleCount(); ++i )
    {
        ModuleInfo* module = moduleGetModuleByIndex( i );

        if ( module->flags & MODULE_FLAG_ENABLED && 
            !( module->flags & MODULE_FLAG_SHUTDOWN ) )
        {
            printf( "modprx: shutting down module %s (%s)\n", module->longName, module->shortName );
            if ( module->shutdown ) module->shutdown();
            module->flags |= MODULE_FLAG_SHUTDOWN;
        }
    }

    printf( "modprx: shutdown finished\n" );
    return SYS_PRX_STOP_OK;
}
